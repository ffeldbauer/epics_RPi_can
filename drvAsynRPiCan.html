<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>drvAsynRPiCan</title>
</head>
<body>
  <div style="text-align: center">
    <h1>drvAsynRPiCan: Asynchronous Port Driver Support</h1>
    <h2>For Raspberry Pi CAN bus interface</h2>
    <p><span style="font-weight: bold; font-size: 14pt">Release 1-00</span></p>
    <p><span style="font-weight: bold; font-size: 14pt">Florian Feldbauer</span></p>
    <p><span style="font-weight: bold; font-size: 14pt">November , 2012</span></p>
  </div>
  <hr />
  <div style="text-align: center">
    <h2>Contents</h2>
  </div>
  <div>
    <a href="#DeviceSupport">Generic Device Support for EPICS records from AsynDriver</a><br />
    <a href="#drvAsynRPiCan">drvAsynRPiCan</a><br />
    <a href="#drvAsynIsegHv">drvAsynIsegHv</a><br />
    <a href="#drvAsynWienerVme">drvAsynWienerVme</a><br />
    <a href="#drvAsynTHMP">drvAsynTHMP</a><br />
    <a href="#drvAsynLedPulser">drvAsynLedPulser</a><br />
    <a href="#install">Install and Build</a><br />

  </div>
  <hr />
  <div style="text-align: center">
    <h2 id="DeviceSupport">Generic Device Support for EPICS records from AsynDriver</h2>
  </div>
  <p>Generic device support is provided for standard EPICS records by the AsynDriver module.
     For the AsynPortDrivers defined in this package the following interfaces are used:<br/>
  <i>Extract from the AsynDriver Documentation:</i></p>
  <ul>
    <li>devAsynInt32 - support for drivers that implement interface asynInt32</li>
    <li>devAsynUInt32Digital - support for drivers that implement interface asynUInt32Digital</li>
    <li>devAsynFloat64 - support for drivers that implement interface asynFloat64</li>
  </ul>
  <p>The support uses the following conventions for DTYP and INP. OUT fields are the same as INP.</p>
  <pre>  field(DTYP,"asynXXX")
  field(INP,"@asyn(portName,addr,timeout)drvParams")
   or
  field(INP,"@asynMask(portName,addr,mask,timeout)drvParams")</pre>
  <p>where
  <ul>
    <li>XXX - The name of the type of interface supported.
    <li>portName - The name of the port.
    <li>addr - The address. If addr is not specified the default is 0.
    <li>mask - This is for devAsynUInt32Digital. It is also used by devAsynInt32 to specify the number of
          bits of the hardware device for drivers that do not support getBounds().
    <li>timeout - The timeout value for asynUser.timeout. If not specified the default is 1.0.
    <li>drvParams - This is passed to the low level driver via the asynDrvUser interface.
  </ul>
  <p>For example:</p>
  <pre>  field(DTYP, "asynInt32")
  field(INP,  "@asyn(portA,0,.1)thisIsForDriver")</pre>
  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynRPiCan">drvAsynRPiCan</h2>
  </div>
  <p>The drvAsynRPiCan driver supports devices connected to the CAN interface.
     It does not provide an interface for accessing it directly from a record
     on the IOC. It is used as lower-level driver for the communication with
     the hardware.<br /><br />
     CAN interfaces are configured with the <tt>drvAsynRPiCanConfigure</tt> command:</p>
  <pre>  drvAsynRPiCanConfigure( "portName", "canName", bitrate )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>canName - The name of the local CAN interface (e.g. "/dev/can", "COM1").</li>
    <li>bitrate - The bitrate used for CAN messages in bit/s.<br />
      Allowed values are: 5000, 10000, 20000, 50000, 100000, 125000, 250000, 500000, and 1000000</li>
  </ul>

  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynIsegHv">drvAsynIsegHv</h2>
  </div>
  <p>The drvAsynIsegHv driver supports the ISEG EHS/EDS high voltage modules.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A high voltage module is configured with the <tt>drvAsynIsegHvConfigure</tt> command:</p>
  <pre>  drvAsynIsegHvConfigure( "portName", "CANport", crate_id, module_id )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan driver.</li>
    <li>crate_id - The unique id for the crate in which this modules is placed.<br />
      Allowed values are: 0-7</li>
    <li>module_id - The place of this module inside the crate.<br />
      Allowed values are: 0-7</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>
  <table border="1">
    <thead><tr><th>Parameter</th><th>Type</th><th>Dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>ISEGHV_CHAN_STATUS       </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit status word of a channel </td></tr>
      <tr><td>ISEGHV_CHAN_EVENT_STATUS </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit event status word of a channel </td></tr>
      <tr><td>ISEGHV_CHAN_VMOM         </td><td>asynFloat64       </td><td> r   </td><td> measured voltage of a channel in V</td></tr>
      <tr><td>ISEGHV_CHAN_IMOM         </td><td>asynFloat64       </td><td> r   </td><td> measured current of a channel in &mu;A</td></tr>
      <tr><td>ISEGHV_CHAN_VSET         </td><td>asynFloat64       </td><td> r/w </td><td> setpoint for voltage of a channel in V</td></tr>
      <tr><td>ISEGHV_CHAN_ISET         </td><td>asynFloat64       </td><td> r/w </td><td> current limit of a channel in &mu;A</td></tr>
      
      <tr><td>ISEGHV_MOD_STATUS        </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit status word of the module </td></tr>
      <tr><td>ISEGHV_MOD_EVENT_STATUS  </td><td>asynUInt32Digital </td><td> r   </td><td> 16-bit event status word of the module </td></tr>
      <tr><td>ISEGHV_TEMPERATURE       </td><td>asynFloat64       </td><td> r   </td><td> measured temperature of the module in &deg;C</td></tr>
      <tr><td>ISEGHV_RAMPSPEED         </td><td>asynFloat64       </td><td> r/w </td><td> Ramp speed of the module in <i>%V</i><sub>O,max</sub><br/>maximum is 20%</td></tr>
      <tr><td>ISEGHV_CLEAR_EVENT_STATUS</td><td>asynInt32<sup>1</sup>         </td><td> r/w   </td><td> Clears the event status of the module and all channels</td></tr>
      
      <tr><td>ISEGHV_EMERGENCYOFF      </td><td>asynInt32<sup>1</sup>         </td><td> r/w   </td><td> Switch all channels of the module off w/o ramp</td></tr>
      <tr><td>ISEGHV_SWITCHONOFF       </td><td>asynUInt32Digital </td><td> r/w   </td><td> Switch all channels of the module on or off<br/>(Mask should be 1)</td></tr>
    </tbody>
  </table>
  <p>The ADDR parameter is used as channel number for the device (0-15).
    All module related parameters have ADDR = 0<sup>2</sup>.<br/>
    The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver.</p>
  <p>An additional "global" driver can be used to switch on/off all channels of the whole CAN bus:
    <pre>  drvAsynIsegHvGlobalConfigure( "portName", "CANport" )</pre>
    This driver has only the parameters ISEGHV_EMERGENCYOFF and ISEGHV_SWITCHONOFF.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynWienerVme">drvAsynWienerVme</h2>
  </div>
  <p>The drvAsynWienerVme driver supports the Wiener VME crate remote control.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A VME remote control is configured with the <tt>drvAsynWienerVmeConfigure</tt> command:</p>
  <pre>  drvAsynWienerVmeConfigure( "portName", "CANport", crate_id )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan driver.</li>
    <li>crate_id - The unique id for the crate.<br />
      Allowed values are: 1-127</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>

  <table border="1" rules="groups">
    <thead><tr><th>Parameter</th><th>Type</th><th>dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>WIENER_VME_STATUS0         </td><td> asynUInt32Digital </td><td>  r   </td><td> Statusbyte 0 of the crate</td></tr>
      <tr><td>WIENER_VME_STATUS1         </td><td> asynUInt32Digital </td><td>  r   </td><td> Statusbyte 1 of the crate</td></tr>
      <tr><td>WIENER_VME_STATUS2         </td><td> asynUInt32Digital </td><td>  r   </td><td> Under voltage error flags</td></tr>
      <tr><td>WIENER_VME_STATUS3         </td><td> asynUInt32Digital </td><td>  r   </td><td> Over voltage error flags</td></tr>
      <tr><td>WIENER_VME_STATUS4         </td><td> asynUInt32Digital </td><td>  r   </td><td> External temperature error flags</td></tr>
      <tr><td>WIENER_VME_STATUS5         </td><td> asynUInt32Digital </td><td>  r   </td><td> Over current error flags</td></tr>
      <tr><td>WIENER_VME_STATUS6         </td><td> asynUInt32Digital </td><td>  r   </td><td> OVP error flags</td></tr>
      <tr><td>WIENER_VME_STATUS7         </td><td> asynUInt32Digital </td><td>  r   </td><td> Power supply temperature error flags</td></tr>
      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM0           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 0 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM0           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 0 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM4           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 4 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM4           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 4 in A/100</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM1           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 1 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM1           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 1 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM5           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 5 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM5           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 5 in A/100</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM2           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 2 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM2           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 2 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM6           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 6 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM6           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 6 in A/100</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_VMOM3           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 3 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM3           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 3 in A/100</td></tr>
      <tr><td>WIENER_VME_VMOM7           </td><td> asynInt32 </td><td>          r   </td><td> Measured voltage channel 7 in V/100</td></tr>
      <tr><td>WIENER_VME_IMOM7           </td><td> asynInt32 </td><td>          r   </td><td> Measured current channel 7 in A/100</td></tr> 

      </tbody><tbody>
      <tr><td>WIENER_VME_FANMIDDLE       </td><td> asynInt32 </td><td>          r   </td><td> Middle speed of all 6 fans in rps</td></tr>
      <tr><td>WIENER_VME_FANNOMINAL      </td><td> asynInt32 </td><td>          r   </td><td> Nominal speed of all 6 fans in rps</td></tr>
      <tr><td>WIENER_VME_FAN1            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 1 in rps</td></tr>
      <tr><td>WIENER_VME_FAN2            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 2 in rps</td></tr>
      <tr><td>WIENER_VME_FAN3            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 3 in rps</td></tr>
      <tr><td>WIENER_VME_FAN4            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 4 in rps</td></tr>
      <tr><td>WIENER_VME_FAN5            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 5 in rps</td></tr>
      <tr><td>WIENER_VME_FAN6            </td><td> asynInt32 </td><td>          r   </td><td> Speed of fan 6 in rps</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_TEMP1           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 1 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP2           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 2 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP3           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 3 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP4           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 4 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP5           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 5 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP6           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 6 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP7           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 7 in &deg;C</td></tr>
      <tr><td>WIENER_VME_TEMP8           </td><td> asynInt32 </td><td>          r   </td><td> External temperature 8 in &deg;C</td></tr>

      </tbody><tbody>
      <tr><td>WIENER_VME_SWITCHONOFF     </td><td> asynUInt32Digital </td><td>          r/w </td><td> Switch crate on/off<br/>(Mask should be 1)</td></tr> 
      </tbody><tbody>
      <tr><td>WIENER_VME_SYSRESET        </td><td> asynInt32<sup>1</sup> </td><td>          r/w   </td><td> Perform system reset</td></tr> 
      </tbody><tbody>
      <tr><td>WIENER_VME_FANSPEED        </td><td> asynInt32 </td><td>          r/w   </td><td> Change nominal speed of all 6 fans</td></tr>
    </tbody>
  </table>
  <p>The paramters are arranged in blocks. Each block is updated when the first paramter was read.
    The other paramters should be triggered using SCAN=''I/O INTR''.<br/>
    The VME crate doesn't use the ADDR parameter, therfore it is always 0.<br/>
  The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynTHMP">drvAsynTHMP</h2>
  </div>
  <p>The drvAsynTHMP driver supports the THMP. It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A THMP is configured with the <tt>drvAsynTHMPConfigure</tt> command:</p>
  <pre>  drvAsynTHMPConfigure( "portName", "CANport", can_id )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan driver.</li>
    <li>can_id - The unique CAN id for this THMP.<br />
      Allowed values are: 0x700-0x7ff</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>
  <table border="1">
    <thead><tr><th>Parameter</th><th>Type</th><th>Dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>THMP_RAWVALUE </td><td>asynInt32 </td><td> r   </td><td>ADC conversion result for one read-out channel </td></tr>
      <tr><td>THMP_IOBOARD </td><td>asynUInt32Digital </td><td> r/w </td><td>16-bit value for one I/O board </td></tr>
      <tr><td>THMP_SERIALS </td><td>asynUInt32Digital </td><td> r </td><td>2*3-byte unique serial id of the 8 piggyback boards an the mainboard</td></tr>
      <tr><td>THMP_FIRMWARE </td><td>asynUInt32Digital </td><td> r </td><td>16-bit firmware code</td></tr>
      <tr><td>THMP_ERROR </td><td>asynUInt32Digital </td><td> r </td><td>16-bit error message from THMP</td></tr>
      <tr><td>THMP_CONFIG_IO </td><td>asynInt32 </td><td> r/w </td><td>8-bit I<sup>2</sup>C-Address offset for one I/O board</td></tr>
      <tr><td>THMP_TRG_ADC </td><td>asynInt32<sup>1</sup> </td><td> r/w </td><td>Trigger read-out of ADC conversion results</td></tr>
      <tr><td>THMP_TRG_IO </td><td>asynInt32<sup>1</sup> </td><td> r/w </td><td>Trigger read-out of I/O boards</td></tr>
      <tr><td>THMP_TRG_SERIALS </td><td>asynInt32<sup>1</sup> </td><td> r/w </td><td>Trigger read-out of serial ids</td></tr>
    </tbody>
  </table>
  <p>The ADDR parameter is used as channel number for the device<sup>2</sup>:</p>
  <ul>
    <li>THMP_RAWVALUE supports ADDR = 0-63</li>
    <li>THMP_SERIALS supports ADDR = 0-17 (0-8: higher 3 bytes of serials; 9-17: lower 3 bytes of serials)</li> 
    <li>THMP_CONFIG_IO and THMP_IOBOARD support ADDR = 0,1</li>
  </ul>

  <hr />
  <div style="text-align: center">
    <h2 id="drvAsynLedPulser">drvAsynLedPulser</h2>
  </div>
  <p>The drvAsynLedPulser driver supports the LED Pulser used by the EMC group of the PANDA collaboration.
    It uses the drvAsynRPiCan driver as lower-level driver.
    Therefore the drvAsynRPiCan driver has to be configured before using this driver.
    <br /><br />
    A LED Pulser is configured with the <tt>drvAsynLedPulserConfigure</tt> command:</p>
  <pre>  drvAsynLedPulserConfigure( "portName", "CANport", can_id, "filename" )</pre>
  <p>where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>CANport - The name of a previous configured drvAsynRPiCan driver.</li>
    <li>can_id - The unique CAN Bus id of this LED Pulser.<br />
      Allowed values are: 0x600-0x6ff</li>
    <li>filename - The name of the file containing calibration parameters for intensity settings.<br/>
    This file must be a plain text file containing a list of pairs of the parameters: "<tt>DAC-value Intensity[%]</tt>"</li>
  </ul>
  <p>Accessing this driver from the IOC is done by the standard device support from asynDriver.
    The driver parameters (drvParams) are:</p>
  <table border="1">
    <thead><tr><th>Parameter</th><th>Type</th><th>Dir</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>LEDPULSER_INTENSITY  </td><td>asynFloat64 </td><td> r/w  </td><td> Intensity of the LED pulser in % </td></tr>
      <tr><td>LEDPULSER_FREQUENCY  </td><td>asynFloat64 </td><td> r/w  </td><td> Frequency of the LED pulser in kHz<br/>
                                                                                 (Allowed values 0-500)</td></tr>
      <tr><td>LEDPULSER_CYCLES     </td><td>asynInt32   </td><td> r/w  </td><td> Number of cycles<br/> 
                                                                                 (Allowed values 0-65525; 65525=continous)</td></tr>
      <tr><td>LEDPULSER_TRG_MODE   </td><td>asynUInt32Digital   </td><td> r/w  </td><td> Trigger Mode (internal/external)<br/>
                                                                                 (Mask should be 1)</td></tr>
      <tr><td>LEDPULSER_COLOR      </td><td>asynUInt32Digital   </td><td> r/w  </td><td> Which LED is triggered (blue, green, red, off) <br/>
                                                                                 (Mask should be 3)</td></tr>
      <tr><td>LEDPULSER_WRITE      </td><td>asynInt32<sup>1</sup>   </td><td> r/w  </td><td> Send all parameters to LED Pulser </td></tr>
      <tr><td>LEDPULSER_READ       </td><td>asynInt32<sup>1</sup>   </td><td> r/w  </td><td> Read all parameters from LED Pulser </td></tr>
    </tbody>
  </table>
  <p>The LED Pulser doesn't use the ADDR parameter, therfore it is always 0.<br/>
    The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver.</p>

  <hr />
  <div style="text-align: center">
    <h2 id="install">Install and Build</h2>
  </div>
  <p>After obtaining a copy of the distribution, it must be installed and built for use
    at your site. Therefore you have to follow these steps:</p>
  <ol>
    <li>Download and build EPICS base (3.14.12.2 or newer): <a href="http://www.aps.anl.gov/epics/" target="new">http://www.aps.anl.gov/epics/</a></li>
    <li>Download the AsynDriver module (4-20 or newer): <a target="new" href="http://www.aps.anl.gov/epics/modules/soft/asyn/">http://www.aps.anl.gov/epics/modules/soft/asyn/</a><br />
      Version 4.20 has a Bug in the devAsynUInt32Digital device support interrupt routine causing EPICS to suspend
      the AsynPortDriver. Also in version 4.20 are implementations needed by this Drivers missing.
      The patch file <tt>fix_asyn-4.20.patch</tt> contains a fix for the bug and the missing implementations.</li>
    <li>Apply the <tt>drvAsynRPiCan.patch</tt> contained in this package to the AsynDriver module<br />
    and copy the directory <tt>drvAsynRPiCan</tt> into the AsynDriver top directory</li>
    <li>Build the AsynDriver module</li>
  </ol>
<hr/>
<p><span style="font-size: 8pt">1: These parameters are used as command, which means the value of these
   parameters will never change</span><br/>
   <span style="font-size: 8pt">2: Due to the internal structure of AsynPortDrivers all parameters exist
   for all addresses. Write methods for not used parameter address combinations simply return asynSuccess without
   performing any action. The values of these combinations will therefore always be 0</span></p>
</body>
</hmtl>
