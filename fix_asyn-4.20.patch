Index: asyn/devEpics/devAsynUInt32Digital.c
===================================================================================

--- asyn/devEpics/devAsynUInt32Digital.c	2012-05-02 01:00:28.000000000 +0200
+++ asyn/devEpics/devAsynUInt32Digital.c	2012-11-19 13:33:58.396546008 +0100
@@ -395,3 +395,4 @@
      * Instead we just return.  There will then be nothing in the ring buffer, so the first
      * read will do a read from the driver, which should be OK. */
     if (!interruptAccept) return;
+    epicsMutexLock(pPvt->mutexId);


Index: asyn/interfaces/asynGenericPointerSyncIO.c
===================================================================================

--- asyn/interfaces/asynGenericPointerSyncIO.c	2012-03-22 22:55:29.000000000 +0100
+++ asyn/interfaces/asynGenericPointerSyncIO.c	2012-11-19 13:00:42.136688898 +0100
@@ -46,13 +46,16 @@ static asynStatus writeOpOnce(const char
                      void *pvalue, double timeout, const char *drvInfo);
 static asynStatus readOpOnce(const char *port, int addr,
                      void *pvalue,double timeout, const char *drvInfo);
+static asynStatus writeReadOp( asynUser *pasynUser, void *pwrite_buffer,
+                               void *pread_buffer, double timeout );
 static asynGenericPointerSyncIO interface = {
     connect,
     disconnect,
     writeOp,
     readOp,
     writeOpOnce,
-    readOpOnce
+    readOpOnce,
+    writeReadOp
 };
 epicsShareDef asynGenericPointerSyncIO *pasynGenericPointerSyncIO = &interface;
 
@@ -217,3 +220,41 @@ static asynStatus readOpOnce(const char
     disconnect(pasynUser);
     return status;
 }
+
+static asynStatus writeReadOp(asynUser *pasynUser,
+                              void *pwrite_buffer,
+                              void *pread_buffer,
+                              double timeout )
+{
+  asynStatus status, unlockStatus;
+  ioPvt      *pPvt = (ioPvt *)pasynUser->userPvt;
+
+  pasynUser->timeout = timeout;
+  status = pasynManager->lockPort( pasynUser );
+  if( status != asynSuccess ) {
+    return status;
+  }
+  status = pPvt->pasynGenericPointer->write( pPvt->pointerPvt, pasynUser, pwrite_buffer );
+  if( status != asynSuccess ) {
+    goto bad;
+  } else {
+    asynPrint( pasynUser, ASYN_TRACEIO_DEVICE,
+               "asynGenericPointerSyncIO wrote: %p\n",
+               pwrite_buffer );
+  }
+  status = pPvt->pasynGenericPointer->read( pPvt->pointerPvt, pasynUser, pread_buffer );
+  if ( status != asynSuccess ) {
+    goto bad;
+  } else {
+    asynPrint( pasynUser, ASYN_TRACEIO_DEVICE,
+               "asynGenericPointerSyncIO read: %p\n",
+               pread_buffer );
+  }
+
+ bad:
+  unlockStatus = pasynManager->unlockPort(pasynUser);
+  if (unlockStatus != asynSuccess) {
+    return unlockStatus;
+  }
+  return status;
+}


Index: asyn/interfaces/asynGenericPointerSyncIO.h
===================================================================================

--- asyn/interfaces/asynGenericPointerSyncIO.h	2008-06-10 23:06:59.000000000 +0200
+++ asyn/interfaces/asynGenericPointerSyncIO.h	2012-11-19 12:59:56.005935322 +0100
@@ -33,6 +33,7 @@ typedef struct asynGenericPointerSyncIO
                        void *pvalue,double timeout,const char *drvInfo);
     asynStatus (*readOnce)(const char *port, int addr,
                        void *pvalue,double timeout,const char *drvInfo);
+    asynStatus (*writeRead)(asynUser *pasynUser,void *pwrite_buffer,void *pread_buffer,double timeout);
 } asynGenericPointerSyncIO;
 epicsShareExtern asynGenericPointerSyncIO *pasynGenericPointerSyncIO;
 
